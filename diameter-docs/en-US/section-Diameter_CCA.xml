<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "docbookV4.5/docbookx.dtd" []>
<section id="cca-Credit_Control_Application">
  <title>Mobicents Diameter CCA</title>
  <para><!--TODO: Developer:  Did you incorporate the wiki content into this section from here: http://groups.google.com/group/mobicents-public/web/mobicents-diameter-cca, 

I'm sorry, but there are huge gaps in this section, and I'm finding it really difficult to work out what content you've incorporated.-->The Credit Control Application (CCA) provides a common interface  for credit applications. CCA defines a minimal  set of Java primitives that  enable  credit session management,  and convey sufficient  information for  applications to perform charging activities.</para>
  <para>For detailed information regarding the Diameter Credit Control Application, refer to the <ulink url="http://tools.ietf.org/html/rfc4006">IETF RFC4006 memorandum</ulink>.   <xref linkend="table-Diameter_CCA_Messages"/> describes the messages that are compatible with declared state machines.</para>
  <table frame="all" pgwide="1" id="table-Diameter_CCA_Messages">
    <title>Diameter CCA Messages</title>
    <tgroup cols="5" colsep="1">
      <colspec colname="c1"/>
      <colspec colname="c2"/>
      <colspec colname="c3"/>
      <colspec colname="c4"/>
      <colspec colname="c5"/>
      <thead>
        <row>
          <entry>Command Name</entry>
          <entry>Abbreviation</entry>
          <entry>Code</entry>
          <entry>Source</entry>
          <entry>Destination</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>Credit-Control-Request</entry>
          <entry>CCR</entry>
          <entry>272</entry>
          <entry>equipment</entry>
          <entry>server</entry>
        </row>
        <row>
          <entry>Credit-Control-Answer</entry>
          <entry>CCA</entry>
          <entry>272</entry>
          <entry>server</entry>
          <entry>equipment</entry>
        </row>
      </tbody>
    </tgroup>
  </table>
  <para>RFC decalres only basic charging scenarios, which are event charging. <!--TODO: Developer:  This is where this sentence ends.  I don't know what's supposed to come after this, but I assume there's something...--></para>
  <section>
    <title>Configuration</title>
    <para>The CCA RA does not support any configuration options.</para>
  </section>
  <section>
    <title>Resource Adaptor Type</title>
    <para>The CCA Resource Adaptor Type provides the following types:</para>
    <itemizedlist>
      <listitem>
        <para>Activities</para>
      </listitem>
      <listitem>
        <para>Provider</para>
      </listitem>
      <listitem>
        <para>Message Factory</para>
      </listitem>
    </itemizedlist>
    <formalpara>
      <title>Activities</title>
      <para>The following activities are available, with the API definition listed for reference.  The API defines methods to easily create and send answers and requests for a certain activity, in addition to retrieving session-specific data.</para>
    </formalpara>
    <para>The lifecycle of an activity depends on the type of received request and the application interaction.  In the case of a subscription activity, the activity  timeout is taken into consideration because the subscription may be time-based.  </para>
    <para>The activitites allow the CCA to retrieve messages and AVP factories bound to the current session.  The functionality offered is limited only  by the implementation used. </para>
    <para>Each Request type is defined by the <literal>CC-Request-Type</literal> Attribute Value Pair (AVP).  The types of activities are described below: </para>
    <itemizedlist>
      <listitem>
        <para>event-based - when <literal>CC-Request-Type = EVENT</literal>. Activities created for this kind of request are terminated once an answer is sent(server)/received(client) or when the session termianted due to lack of an answer.</para>
      </listitem>
      <listitem>
        <para>session-based - when the first message contains <literal>CC-Request-Type = INITIAL</literal>, and the last message contains  <literal>CC-Request-Type = TERMINATION</literal>. Any number of &quot;UPDATE&quot; messages are allowed between the  initial and termianting message.</para>
      </listitem>
    </itemizedlist>
    <variablelist>
      <title>CCA Activities</title>
      <varlistentry>
        <term>CreditControlClientSession</term>
        <listitem>
          <para>Created on demand. The life cycle of this session depends on the type of request. The request type is indicated by <literal>CC-Request-Type</literal> AVP. </para>
          <programlisting role="JAVA">/**
   * Create a Credit-Control-Request message pre-populated with the AVPs
   * appropriate for this session.
   * 
   * @return a new CreditControlRequest
   */
  CreditControlRequest createCreditControlRequest();

  /**
   * Send an event Credit-Control-Request. An event containing the answer will
   * be fired on this activity.
   * 
   * @param ccr the CreditControlRequest to send
   * @throws IOException
   */
  void sendCreditControlRequest(CreditControlRequest ccr) throws IOException;

  /**
   * Send an initial Credit-Control-Request. An event containing the answer
   * will be fired on this activity.
   * 
   * @param ccr the CreditControlRequest to send
   * @throws IOException
   */
  void sendInitialCreditControlRequest(CreditControlRequest ccr) throws IOException;

  /**
   * Send a Re-Auth-Answer message.
   * 
   * @param rar the CreditControlRequest to send
   * @throws IOException
   */
  void sendReAuthAnswer(ReAuthAnswer rar) throws IOException;

  /**
   * Send an update (intermediate) Credit-Control-Request. An event containing
   * the answer will be fired on this activity.
   * 
   * @param ccr the CreditControlRequest to send
   * @throws IOException
   */
  void sendUpdateCreditControlRequest(CreditControlRequest ccr) throws IOException;

  /**
   * Send a termination Credit-Control-Request. An event containing the answer
   * will be fired on this activity. The activity will end when the event is
   * fired.
   * 
   * @param ccr the CreditControlRequest to send
   * @throws IOException 
   */
  void sendTerminationCreditControlRequest(CreditControlRequest ccr) throws IOException;
/**
   * Provides session state information. CC session must conform to CC FSM as
   * described in &lt;a href=&quot;link http://rfc.net/rfc4006.html#s7&quot;&gt;section 7 of rfc4006&lt;/a&gt;
   * 
   * @return instance of {@link CreditControlSessionState}
   */
  public CreditControlSessionState getState();

  /**
   * Returns the session ID of the credit control session, which uniquely
   * identifies the session.
   * 
   * @return 
   */
  public String getSessionId();

  public CreditControlAVPFactory getCCAAvpFactory();

  public CreditControlMessageFactory getCCAMessageFactory();
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>CreditControlServerSession</term>
        <listitem>
          <para>Created once a request is received and there is no matching activity for it. Its life cycle is identical to that of a client activity.</para>
          <programlisting role="JAVA"> /**
   * Create a Credit-Control-Answer message pre-populated with the AVPs
   * appropriate for this session.
   * 
   * @return a new CreditControlAnswer
   */
  CreditControlAnswer createCreditControlAnswer();

  /**
   * Send a Credit-Control-Answer message to the CC client.
   * 
   * @param cca the CreditControlAnswer to send
   * @throws IOException
   */
  void sendCreditControlAnswer(CreditControlAnswer cca) throws IOException;

  /**
   * Send a Re-Auth-Request message to the CC client.
   * 
   * @param rar the ReAuthRequest to send
   * @throws IOException 
   * @throws IOException
   */
  void sendReAuthRequest(ReAuthRequest rar) throws IOException;
/**
   * Provides session state information. CC session must conform to CC FSM as
   * described in &lt;a href=&quot;link http://rfc.net/rfc4006.html#s7&quot;&gt;section 7 of rfc4006&lt;/a&gt;
   * 
   * @return instance of {@link CreditControlSessionState}
   */
  public CreditControlSessionState getState();

  /**
   * Returns the session ID of the credit control session, which uniquely
   * identifies the session.
   * 
   * @return 
   */
  public String getSessionId();

  public CreditControlAVPFactory getCCAAvpFactory();

  public CreditControlMessageFactory getCCAMessageFactory();</programlisting>
        </listitem>
      </varlistentry>
    </variablelist>
    <formalpara>
      <title>Provider</title>
      <para>Provider allows services to create activities, access some topology information and send/receive message in a synchronised way. </para>
    </formalpara>
    <programlisting role="JAVA">public interface CreditControlProvider {

  /**
   * Create a new client session to send and receive Diameter messages.
   * All messages sent on an activity created by this method must contain valid
   * routing AVPs (one or both of Destination-Realm and Destination-Host as
   * defined by RFC3588).
   * 
   * @return a instance of a CreditControlClientSession to send credit control messages
   */
  public CreditControlClientSession createClientSession()throws CreateActivityException;

  /**
   * Create a new client session to send and receive Diameter messages.
   * Messages sent on an activity created by this method will automatically
   * have the Destination-Host and Destination-Realm AVPs set to the provided
   * values.
   * 
   * @param destinationHost a destination host to automatically put in all messages, may be null if not needed
   * @param destinationRealm a destination realm to automatically put in all messages
   * @return a instance of a CreditControlClientSession to send credit control messages
   * @throws CreateActivityException 
   */
  public CreditControlClientSession createClientSession(
      DiameterIdentity destinationHost,
      DiameterIdentity destinationRealm) throws CreateActivityException;

  /**
   * Return a message factory to be used to create credit control messages
   * 
   * @return a CreditControlMessageFactory implementation
   */
  public CreditControlMessageFactory getCreditControlMessageFactory();

  /**
   * Return a AVP factory to be used to create credit control AVPs
   * 
   * @return a CreditControlAVPFactory implementation
   */
  public CreditControlAVPFactory getCreditControlAVPFactory();

  /**
   * Return the number of peers this Diameter resource adaptor is connected
   * to.
   * 
   * @return connected peer count
   */
  int getPeerCount();

  /**
   * Returns array containing identities of connected peers FIXME: baranowb; -
   * should it be InetAddres, Port pair?
   * 
   * @return
   */
  DiameterIdentity[] getConnectedPeers();</programlisting>
  </section>
  <section>
    <title>API Usage Examples</title>
    <para>The following example shows how a CCR message is created and sent.</para>
    <example>
      <title>Sending CCR</title>
      <programlisting role="JAVA">try {
CreditControlClientSession session = this.provider.createClientSession();
ActivityContextInterface localACI = this.acif.getActivityContextInterface(session);
localACI.attach(this.getSbbContext().getSbbLocalObject());

CreditControlRequest request = session.createCreditControlRequest();

List&lt;DiameterAvp&gt; avps = new ArrayList&lt;DiameterAvp&gt;();

avps.add(avpFactory.getBaseFactory().createAvp(Avp.ORIGIN_HOST, (&quot;aaa://&quot; + originIP + &quot;:&quot; + originPort).getBytes()));
avps.add(avpFactory.getBaseFactory().createAvp(Avp.ORIGIN_REALM, originRealm.getBytes()));

avps.add(avpFactory.getBaseFactory().createAvp(Avp.DESTINATION_HOST, (&quot;aaa://&quot; + destinationIP + &quot;:&quot; + destinationPort).getBytes()));
avps.add(avpFactory.getBaseFactory().createAvp(Avp.DESTINATION_REALM, destinationRealm.getBytes()));

avps.add(avpFactory.getBaseFactory().createAvp(CreditControlAVPCodes.CC_Request_Type, 4l));
avps.add(avpFactory.getBaseFactory().createAvp(CreditControlAVPCodes.CC_Request_Number, 0l));

RequestedServiceUnitAvp rsu = this.avpFactory.createRequestedServiceUnit();

CcMoneyAvp ccMoney = this.avpFactory.createCcMoney();
ccMoney.setCurrencyCode(100);
ccMoney.setUnitValue(this.avpFactory.createUnitValue());

rsu.setCreditControlInputOctets(10);
rsu.setCreditControlMoneyAvp(ccMoney);
rsu.setCreditControlServiceSpecificUnits(1000);
rsu.setCreditControlTime(100);
rsu.setCreditControlTotalOctets(5000);

avps.add(rsu);

avps.add(avpFactory.getBaseFactory().createAvp(CreditControlAVPCodes.Requested_Action, 0));

// Now create &amp; send
request.setExtensionAvps(avps.toArray(new DiameterAvp[avps.size()]));
if (logger.isInfoEnabled())
logger.info(&quot;About to send:\n&quot; + request);

session.sendCreditControlRequest(request);
} catch (Exception e) {
logger.error(&quot;Failed to create/send Credit-Control-Request.&quot;, e);
}</programlisting>
    </example>
    <para>The following code demonstrates how the CCR is received and how different state machines are handled.</para>
    <example>
      <title>Handling CCR</title>
      <programlisting role="JAVA">public void onCreditControlRequest(CreditControlRequest request, ActivityContextInterface aci) {
if (logger.isInfoEnabled())
logger.info(&quot;Received Credit-Control-Request (Application-Id[&quot; + request.getHeader().getApplicationId() + &quot;].&quot;);

// INITIAL_REQUEST(1), UPDATE_REQUEST(2), TERMINATION_REQUEST(3),
// EVENT_REQUEST(4)
CreditControlServerSession session = (CreditControlServerSession) aci.getActivity();
CreditControlAnswer answer = null;

switch (request.getCcRequestType().getValue()) {
case 1:
try {
if (logger.isInfoEnabled())
logger.info(&quot;Got INITIAL_REQUEST(1).&quot;);

if (getSentInitialAnswer()) {
logger.error(&quot;Error. Initial answer already sent! Aborting.&quot;);
return;
}

answer = session.createCreditControlAnswer();
answer.setResultCode(2001);
if (logger.isInfoEnabled()) {
logger.info(&quot;Processed Credit-Control-Request:\n&quot; + request);
logger.info(&quot;Sending Credit-Control-Answer:\n&quot; + answer);
}

session.sendCreditControlAnswer(answer);
this.setSentInitialAnswer(true);
} catch (Exception e) {
logger.error(&quot;Failed to create/send Credit-Control-Answer to reply INITIAL_REQUEST(1).&quot;, e);
}
break;
case 2:
try {
if (logger.isInfoEnabled())
logger.info(&quot;Got UPDATE_REQUEST(2).&quot;);

if (getSentUpdateAnswer()) {
logger.error(&quot;Error. Update answer already sent! Aborting.&quot;);
return;
}

answer = session.createCreditControlAnswer();
answer.setResultCode(2001);
if (logger.isInfoEnabled()) {
logger.info(&quot;Processed Credit-Control-Request:\n&quot; + request);
logger.info(&quot;Sending Credit-Control-Answer:\n&quot; + answer);
}
session.sendCreditControlAnswer(answer);
setSentUpdateAnswer(true);
} catch (Exception e) {
logger.error(&quot;Failed to create/send Credit-Control-Answer to reply UPDATE_REQUEST(2).&quot;, e);
}
break;
case 3:
try {
if (logger.isInfoEnabled())
logger.info(&quot;Got TERMINATION_REQUEST(3).&quot;);

if (getSentTerminationAnswer()) {
logger.error(&quot;Error. Termination answer already sent! Aborting.&quot;);
return;
}

answer = session.createCreditControlAnswer();
answer.setResultCode(2001);
if (logger.isInfoEnabled()) {
logger.info(&quot;Processed Credit-Control-Request:\n&quot; + request);
logger.info(&quot;Sending Credit-Control-Answer:\n&quot; + answer);
}
session.sendCreditControlAnswer(answer);
setSentTerminationAnswer(true);
} catch (Exception e) {
logger.error(&quot;Failed to create/send Credit-Control-Answer to reply TERMINATION_REQUEST(3).&quot;, e);
}
break;
case 4:
try {
if (logger.isInfoEnabled())
logger.info(&quot;Got EVENT_REQUEST(4).&quot;);

answer = session.createCreditControlAnswer();
answer.setResultCode(2001);
if (logger.isInfoEnabled())
logger.info(&quot;Sending Credit-Control-Answer:\n&quot; + answer);

session.sendCreditControlAnswer(answer);
} catch (Exception e) {
logger.error(&quot;Failed to create/send Credit-Control-Answer to reply EVENT_REQUEST(4).&quot;, e);
}
break;

default:
logger.error(&quot;Unexpected CC-Request-Type in message: &quot; + request.getCcRequestType() + &quot;. Aborting...&quot;);
}
}</programlisting>
    </example>
  </section>
  <section>
    <title>Examples</title>
    <para>The sample application provided for CCA is a very basic one.It supports three separate scenarios:</para>
    <itemizedlist>
      <listitem>
        <para>Client</para>
      </listitem>
      <listitem>
        <para>Server for event charging</para>
      </listitem>
      <listitem>
        <para>Server for session based charging</para>
      </listitem>
    </itemizedlist>
    <formalpara>
      <title>Client</title>
      <para>The example acts as a CCA client . It issues an order to charge an entity (unspecified) account with a defined number of units. It sends a CCR to the Ericsson Diameter Server (EDS).  If the message is correctly built, the server will send an answer back to the application stating that the operation was executed correctly.  If the message is incorrectly built, the EDS sends an error message back to the application.</para>
    </formalpara>
<!--Note: Developers: Am leaving this section unedited as it makes no sense. I need a more structured, logical explanation of what the example is if I am going to rewrite it coherently.-->    <formalpara>
      <title>Server for event charging</title>
      <para>The example service acts as a simple server. It awaits for a CCR message. Once the client sends it (EDS), the  service receives it. The simplest processing of this request includes only sending success answer</para>
    </formalpara>
    <formalpara>
      <title>Server for session based charging</title>
      <para>The service awaits a session based exchange - that is CCRs with CC-Request-Type which follows sequence INITIAL, UPDATE(zero or more) and TERMINATION.</para>
    </formalpara>
    <section>
      <title>Example Configuration</title>
      <para>The example is configured via the file <filename>example.properties</filename></para>
      <programlisting># Act as &quot;client&quot; or &quot;server&quot; (default: server)
example.mode=client

# The AS IP Address, Port and Realm (default: 127.0.0.1 / 1812 / mobicents.org)
origin.ip=127.0.0.1
origin.port=1812
origin.realm=mobicents.org

# The Remote IP Address, Port and Realm (default: 127.0.0.1 / 3868 / mobicents.org)
destination.ip=127.0.0.1
destination.port=3868
destination.realm=mobicents.org</programlisting>
    </section>
  </section>
</section>
