<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [<!ENTITY % BOOK_ENTITIES SYSTEM "User_Guide.ent">%BOOK_ENTITIES;]>

<section id="jdiameter-source_overview">
	<!-- TODO: Developer: add section per each app session and factory, explain how it is created -->
	<title>&THIS.PLATFORM; Diameter Stack Source overview</title>

	<para>&THIS.PLATFORM; Diameter stack is built with the following basic components:</para>
	<para>
		<variablelist>
			<varlistentry>
				<term>Session Factory</term>
				<listitem>
					<para>Session Factory governs creation of sessions - raw and specific application sessions.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Raw and Application Sessions</term>
				<listitem>
					<para>Sessions govern stateful message routing between peers. Specific application sessions consume different type of messages and act differently based on data present.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>Stack</term>
				<listitem>
					<para>Stack governs all necessary components which allow to establish connection and communicate with remote peers.</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<note>
			<para>For more detailed information please refer to <literal>javadoc</literal> and simple examples which can be found at <ulink url="&THIS.TESTSUITE_TRUNK_SOURCE_CODE_URL;">SVN Testsuite Trunk</ulink>.</para>
		</note>
	</para>
	<section id="jdiameter-source_overview-session_factory">
		<title>Session Factory</title>
		<para><literal>SessionFactory</literal> provides stack user access to session objects. It manages registered application session factories, in order to allow creation of specific application sessions. An Session Factory instance can be obtained from stack with use of <literal>getSessionFactory()</literal> method. Base <literal>SessionFactory</literal> interface is defined as follows:</para>
<programlisting role="JAVA" language="Java">package org.jdiameter.api;

import org.jdiameter.api.app.AppSession;

public interface SessionFactory {

    RawSession getNewRawSession() throws InternalException;

    Session getNewSession() throws InternalException;

    Session getNewSession(String sessionId) throws InternalException;

    &lt;T extends AppSession&gt; T getNewAppSession(ApplicationId applicationId, 
    	Class&lt;? extends AppSession&gt; userSession) throws InternalException;

    &lt;T extends AppSession&gt; T getNewAppSession(String sessionId, ApplicationId
    	 applicationId, Class&lt;? extends AppSession&gt; userSession) throws InternalException;
}</programlisting>
		<para>However, since stack is extensible, it is safe to cast <literal>SessionFactory</literal> object to this interface:</para>
<programlisting role="JAVA" language="Java">package org.jdiameter.client.api;


public interface ISessionFactory extends SessionFactory {

  &lt;T extends AppSession&gt; T getNewAppSession(String sessionId, 
  	ApplicationId applicationId, java.lang.Class&lt;? extends AppSession&gt; 
  		aClass, Object... args) throws InternalException;

  void registerAppFacory(Class&lt;? extends AppSession&gt; sessionClass, 
  	IAppSessionFactory factory);

  void unRegisterAppFacory(Class&lt;? extends AppSession&gt; sessionClass);    
  
  IConcurrentFactory getConcurrentFactory();

}</programlisting>
		<variablelist>
			<varlistentry>
				<term><literal>RawSession getNewRawSession() throws InternalException;</literal></term>
				<listitem><para>This method creates <literal>RawSession</literal>. Raw sessions are meant as handles for code performing part of routing decision on stacks behalf - such as rely agents for instance.</para></listitem>
			</varlistentry>
			<varlistentry>
				<term><literal>Session getNewSession() throws InternalException;</literal></term>
				<listitem><para>This method creates session which acts as endpoint for peer communication(for given session ID). It declares method which work with <literal>Request</literal> and <literal>Answer</literal> objects. Session created with this method has autogenerated ID. It should be considered as <literal>client</literal> session. </para></listitem>
			</varlistentry>
			<varlistentry>
				<term><literal>Session getNewSession(String sessionId) throws InternalException;</literal></term>
				<listitem><para>As above, however created session has Id equal to passsed as argument. Created session should be considered as <literal>server</literal> session.</para></listitem>
			</varlistentry>
			<varlistentry>
				<!-- Docs: is there any way to break this? -->
				<term><literal>&lt;T extends AppSession&gt; T getNewAppSession(ApplicationId applicationId, Class&lt;? extends AppSession&gt; userSession) throws InternalException;</literal></term>
				<listitem><para>This method creates new specific application session, identified by application Id and <literal>class</literal> of session passed. Session Id is generated by implementation. New application session should be considered as <literal>client</literal> session. It is safe to type cast return value to <literal>class</literal> passed as argument. This method delegates call to specific application session factory. </para></listitem>
			</varlistentry>
			<varlistentry>
				<term><literal>&lt;T extends AppSession&gt; T getNewAppSession(String sessionId, ApplicationId applicationId, Class&lt;? extends AppSession&gt; userSession) throws InternalException;</literal></term>
				<listitem><para>As above, however session Id is equal to argument passed. New session should be considered as <literal>sever</literal> session.</para></listitem>
			</varlistentry>
			<varlistentry>
				<term><literal>&lt;T extends AppSession&gt; T getNewAppSession(String sessionId, ApplicationId applicationId, java.lang.Class&lt;? extends AppSession&gt; aClass, Object... args) throws InternalException;</literal></term>
				<listitem><para>As above, however it allows to pass some additional argument. Passed values are implementation specifc.</para></listitem>
			</varlistentry>
			<varlistentry>
				<term><literal>void registerAppFacory(Class&lt;? extends AppSession&gt; sessionClass, IAppSessionFactory factory);</literal></term>
				<listitem><para>registers <literal>factory</literal> for certain <literal>sessionClass</literal>. This factory will receive delegated call when ever <literal>getNewAppSession</literal> method is called with application <literal>class</literal> matching one from register method.</para></listitem>
			</varlistentry>
			<varlistentry>
				<term><literal>void unRegisterAppFacory(Class&lt;? extends AppSession&gt; sessionClass);</literal></term>
				<listitem><para>removes application session factory registered for <literal>sessionClass</literal>. </para></listitem>
			</varlistentry>
			<!-- 
			<varlistentry>
				<term><literal></literal></term>
				<listitem><para></para></listitem>
			</varlistentry>
			 -->
		</variablelist>
		<example>
			<title>SessionFactory use example</title>
<programlisting language="Java" role="JAVA">class Test implements EventListener&lt;Request, Answer&gt;
{

....
public void test(){
	Stack stack = new StackImpl();
	XMLConfiguration config = new XMLConfiguration(new FileInputStream(new File(configFile));

	SessionFactory sessionFactory = stack.init(config);
	stack.start();
	//perferctly legal, both factories are the same.
	sessionFactor = stack.getSessionFactory(); 
	Session session = sessionFactory.getNewSession();
	session.setRequestListener(this);
	Request r = session.createRequest(308,ApplicationId.createByAuth(100L,10101L),
		"mobicents.org","aaa://uas.fancyapp.mobicents.org");
	
	//add avps specific for app
	session.send(r,this);
	}
}</programlisting>
		</example>
		<example>
			<title>SessionFactory use example</title>
<programlisting language="Java" role="JAVA">class Test implements EventListener&lt;Request, Answer&gt;
{
	Stack stack = new StackImpl();
	XMLConfiguration config = new XMLConfiguration(new FileInputStream(new File(configFile));

	ISessionFactory sessionFactory = (ISessionFactory)stack.init(config);
	stack.start();
	//perferctly legal, both factories are the same.
	sessionFactor = (ISessionFactory)stack.getSessionFactory(); 
	sessionFactory.registerAppFacory(ClientShSession.class, new ShClientSessionFactory(this));
	
	//our implementation of factory does not require any parameters
	ClientShSession session = (ClientShSession) sessionFactory.getNewAppSession(null, null
		, ClientShSession.class, null);
	
	...
	session.sendUserDataRequest(udr);
}</programlisting>
		</example>
	</section>
	<section id="jdiameter-source_overview-session">
		<title>Sessions</title>
		<para><literal>RawSession</literal>, <literal>Session</literal> and <literal>ApplicationSession</literal> provide means of disspatching and receiving messages. Specific implementation of <literal>ApplicationSession</literal> may provide non standard methods.</para>
		<para><literal>RawSession</literal> and <literal>Session</literal> life span is controlled entirelly by application. However <literal>ApplicationSession</literal> life time depends on implemented state machine.</para>
		<para><literal>RawSession</literal> is defined as follows:</para>
<programlisting role="JAVA" language="Java">public interface BaseSession extends Wrapper, Serializable {
 
    long getCreationTime();
    
    long getLastAccessedTime();

    boolean isValid();

    Future&lt;Message&gt; send(Message message) throws InternalException, 
    	IllegalDiameterStateException, RouteException, OverloadException;

    Future&lt;Message&gt; send(Message message, long timeOut, TimeUnit timeUnit) 
    	throws InternalException, IllegalDiameterStateException, RouteException, OverloadException;
    
    void release();
}

public interface RawSession extends BaseSession {

    Message createMessage(int commandCode, ApplicationId applicationId, Avp... avp);

    Message createMessage(int commandCode, ApplicationId applicationId, 
    	long hopByHopIdentifier, long endToEndIdentifier, Avp... avp);

    Message createMessage(Message message, boolean copyAvps);

    void send(Message message, EventListener&lt;Message, Message&gt; listener) 
    	throws InternalException, IllegalDiameterStateException, RouteException, OverloadException;

    void send(Message message, EventListener&lt;Message, Message&gt; listener
    	, long timeOut, TimeUnit timeUnit) throws InternalException, 
    		IllegalDiameterStateException, RouteException, OverloadException;
}</programlisting>
		
		<variablelist>
			<varlistentry>		
				<term>long getCreationTime();</term>
				<listitem><para>Returns time stamp of this session creation</para></listitem>
			</varlistentry>
			<varlistentry>		
				<term>long getLastAccessedTime();</term>
				<listitem><para>Returns last time stamp indicating send or receive operation</para></listitem>
			</varlistentry>
			<varlistentry>		
				<term>boolean isValid();</term>
				<listitem><para>Returns <literal>true</literal> when this session is still valid (ie, <literal>release()</literal> has not been called)</para></listitem>
			</varlistentry>
			<varlistentry>		
				<term>void release();</term>
				<listitem><para>Application calls this method to inform that session should free any associated resource - it shall not be used anymore</para></listitem>
			</varlistentry>
			<varlistentry>		
				<term>Future&lt;Message&gt; send(Message message)</term>
				<listitem><para>Sends message in async mode. Provided <literal>Future</literal> reference provides means of accessing answer once its received</para></listitem>
			</varlistentry>
			<varlistentry>		
				<term>void send(Message message, EventListener&lt;Message, Message&gt; listener, long timeOut, TimeUnit timeUnit)</term>
				<listitem><para>As above. Allows to specif time out value for send operation</para></listitem>
			</varlistentry>
			<varlistentry>		
				<term>Message createMessage(int commandCode, ApplicationId applicationId, Avp... avp);</term>
				<listitem><para>Creates a Diameter message. It should be explicitly set either as request or answer. Passed parameters are used to build message</para></listitem>
			</varlistentry>
			<varlistentry>		
				<term>Message createMessage(int commandCode, ApplicationId applicationId, long hopByHopIdentifier, long endToEndIdentifier, Avp... avp);</term>
				<listitem><para>Same as above, however it allow to also set Hop-by-Hop and End-to-End Identifiers in message header. This method should be used to create answers</para></listitem>
			</varlistentry>
			<varlistentry>		
				<term>Message createMessage(Message message, boolean copyAvps);</term>
				<listitem><para>Clones message and returns created object</para></listitem>
			</varlistentry>
			<varlistentry>
				<term>void send(Message message, EventListener&lt;Message, Message&gt; listener)</term>
				<listitem><para>Sends message, answer will be delivered to the specified listener</para></listitem>
			</varlistentry>
			<varlistentry>		
				<term>void send(Message message, EventListener&lt;Message, Message&gt; listener, long timeOut, TimeUnit timeUnit)</term>
				<listitem><para>As above, it allows to pass answer wait timeout</para></listitem>
			</varlistentry>
		</variablelist>
		<para><literal>Session</literal> is defines similar methods, with exactly the same purpose: </para>

<programlisting role="JAVA" language="Java">public interface Session extends BaseSession {
    String getSessionId();

    void setRequestListener(NetworkReqListener listener);

    Request createRequest(int commandCode, ApplicationId appId, String destRealm);

    Request createRequest(int commandCode, ApplicationId appId, String destRealm, String destHost);

    Request createRequest(Request prevRequest);

    void send(Message message, EventListener&lt;Request, Answer&gt; listener) 
    	throws InternalException, IllegalDiameterStateException, RouteException, OverloadException;

    void send(Message message, EventListener&lt;Request, Answer&gt; listener, long timeOut
    	, TimeUnit timeUnit) throws InternalException, IllegalDiameterStateException, 
    		RouteException, OverloadException;
    }</programlisting>
	</section>
</section>
